     1                                  ; tarea programada aquitectura de computadores
     2                                  ; Command-line Interface
     3                                  ;Josue Salas Barrantes 
     4                                  ;Jose Arguedas Castillo
     5                                  
     6                                  
     7                                  ;Esto es para hacer el código más legible
     8                                  sys_exit        equ     1
     9                                  sys_read        equ     3
    10                                  sys_write       equ     4
    11                                  sys_open        equ     5
    12                                  stdin           equ     0
    13                                  stdout          equ     1
    14                                  sys_unlink 		equ	 	10
    15                                  sys_rename 		equ		38
    16                                  sys_link		equ		9
    17                                  
    18                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SECTION .BSS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    19                                  ;|		Buffers para guardar toda la instruccion, argumentos por aparte , lo que dice 		 |
    20                                  ;|		un archivo, y las lineas (en caso de la instruccion comparar)						 |
    21                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    22                                  
    23                                  section .bss
    24                                  
    25                                  
    26                                  	lenConfirmacion		equ		2		; para confirmar si se desea realizar una accion [s/n]
    27 00000000 <res 00000002>          	buffConfirmacion	resb	lenConfirmacion
    28                                  
    29                                  	lenArg	equ 	200				;un tamaño de 300 para guardar todo el argumento, pensado en que sean los nombres de 2 archivos y sea mas largo
    30 00000002 <res 000000C8>          	bufferArg   resb lenArg
    31                                  	
    32                                  	;b	resb 1
    33                                  	
    34                                  	lenArg2	equ	50		; calculando que un archivo puede tener un nombre largo	
    35 000000CA <res 00000032>          	bufferArg2	resb	lenArg2
    36                                  	
    37                                  	lenArg1   equ 11	;calculando la cantidad de letras de una instruccion, mas uno mas para  guardar el enter	 
    38 000000FC <res 0000000B>          	bufferArg1	resb lenArg1
    39                                  	
    40                                  	lenArg3	equ	50		; calculando que un archivo puede tener un nombre largo
    41 00000107 <res 00000032>          	bufferArg3	resb	lenArg3
    42                                  
    43                                  	lenArg4   equ 12	;no es muy grande, lo mas que puede almacenar es el --forzado
    44 00000139 <res 0000000C>          	bufferArg4	resb lenArg4
    45                                  
    46                                  	fileBufLen	equ		1500		
    47 00000145 <res 000005DC>          	fileBuf		resb	fileBufLen
    48                                  	
    49                                  	lenFile1	equ		1500
    50 00000721 <res 000005DC>          	File1		resb lenFile1
    51                                  
    52                                  	lenFile2	equ		1500
    53 00000CFD <res 000005DC>          	File2		resb lenFile2
    54                                  
    55                                  ; en caso de usar la instruccion comparar se guardara cada linea en estos dos buffers
    56 000012D9 <res 00000190>          	linea1		resb	400	
    57 00001469 <res 00000190>          	linea2		resb	400	
    58                                  
    59                                  	
    60                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SECTION . DATA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    61                                  
    62                                  
    63                                  
    64                                  section .data
    65                                  
    66 00000000 636C69666620792074-     msjprompt:                db                "cliff y tito:>>"; El prompt utilizado
    67 00000009 69746F3A3E3E       
    68                                  lenprompt:                equ                $-msjprompt
    69                                  
    70                                  
    71                                  
    72 0000000F 0A                      msgEnter	db "",10
    73                                  lenEnter	equ	$-msgEnter
    74                                  ; ESTOS 6 PARA ABAJO SON PARA IR COMPARANDO CON EL PRIMER ARGUMENTO RECIBIDO
    75 00000010 6D6F737472617220        msgMostar	db "mostrar "
    76 00000018 626F7272617220          msgBorrar	db "borrar "
    77 0000001F 72656E6F6D62726172-     msgRenombrar	db"renombrar "
    78 00000028 20                 
    79 00000029 636F6D706172617220      msgCompara	db "comparar "
    80 00000032 636F7069617220          msgCopiar	db "copiar "
    81 00000039 73616C6972              msgSalir	db "salir"
    82                                  ;PARA LA INSTRUCCION DE COMPARAR, CUANDO TERMINA
    83 0000003E 2D2D53652061636162-     msgFinArchivos	db"--Se acabo uno,o ambos archivos, se dejara de comparar--",10
    84 00000047 6F20756E6F2C6F2061-
    85 00000050 6D626F732061726368-
    86 00000059 69766F732C20736520-
    87 00000062 64656A617261206465-
    88 0000006B 20636F6D7061726172-
    89 00000074 2D2D0A             
    90                                  lenFinArchivos	equ	$-msgFinArchivos
    91                                  
    92                                  ;ESTOS PARA COMPARAR CON LAS INSTRUCCIONES AYUDA Y FORZADO
    93 00000077 2D2D666F727A61646F-     msgForzado	db	"--forzado",10
    94 00000080 0A                 
    95 00000081 2D2D617975646100        msgAyuda	db	"--ayuda",0
    96                                  ;MENSAJE DE CONFIRMACION PARA LAS INSTRUCCIONES QUE LO NECESITA
    97 00000089 205365206465736561-     msgConfirmacion		db " Se desea proceder con la accion solicitada? [s/n] : "
    98 00000092 2070726F6365646572-
    99 0000009B 20636F6E206C612061-
   100 000000A4 6363696F6E20736F6C-
   101 000000AD 696369746164613F20-
   102 000000B6 5B732F6E5D203A20   
   103                                  lenConfirmacionMsg	equ		$-msgConfirmacion
   104                                  
   105                                  ;Archivos de ayuda con la ruta, estan adentro de la carpeta Ayuda
   106 000000BE 41797564612F636F70-     copiarAyuda:  	db 		"Ayuda/copiar.ayuda.txt",0
   107 000000C7 6961722E6179756461-
   108 000000D0 2E74787400         
   109 000000D5 41797564612F72656E-     renombrarAyuda:	db		"Ayuda/renombrar.ayuda.txt",0
   110 000000DE 6F6D627261722E6179-
   111 000000E7 7564612E74787400   
   112 000000EF 41797564612F626F72-     borrarAyuda:	db		"Ayuda/borrar.ayuda.txt",0
   113 000000F8 7261722E6179756461-
   114 00000101 2E74787400         
   115 00000106 41797564612F636F6D-     compararAyuda:	db		"Ayuda/comparar.ayuda.txt",0
   116 0000010F 70617261722E617975-
   117 00000118 64612E74787400     
   118 0000011F 41797564612F6D6F73-     mostrarAyuda: 	db	 	"Ayuda/mostrar.ayuda.txt",0
   119 00000128 747261722E61797564-
   120 00000131 612E74787400       
   121                                  ; MENAJE DE ERROR, CUANDO NO SE ENCUENTRA UNA INSTRUCCION DADA
   122 00000137 4E6F20736520656E63-     msgError 	db "No se encontro la instruccion"
   123 00000140 6F6E74726F206C6120-
   124 00000149 696E73747275636369-
   125 00000152 6F6E               
   126                                  lenError	equ	$-msgError
   127                                  ; MENSAJE QUE SE MUESTRA CUANDO NO SE ENCUENTRA UN ARCHIVO
   128 00000154 4F63757272696F2075-     msgErrorNoArchivo 	db "Ocurrio un error a la hora de abrir el archivo "
   129 0000015D 6E206572726F722061-
   130 00000166 206C6120686F726120-
   131 0000016F 646520616272697220-
   132 00000178 656C20617263686976-
   133 00000181 6F20               
   134                                  lenErrorNoArchivo	equ	$-msgErrorNoArchivo
   135                                  
   136                                  ;UNA "C" SE USA PARA CUANDO SE COMPARA DOS LINEAS, SI SON DIFERENTES SERIA 1c1 ese "c" es este mensaje
   137 00000183 63                      c			db "c"
   138                                  clen		equ $-c
   139                                  
   140                                  
   141                                  ; SE USA PARA GUARDAR EL RESULTADO DE LA INSTRUCCION COMPARAR  Ejemplo 1c1
   142 00000184 00000000                resultado		dd 00
   143                                  lenresulado		equ	$-resultado
   144                                  
   145                                  ;mensaje de logrado
   146 00000188 20456C2070726F6365-     msgListo:	db " El proceso deseado se logro satisfactoriamente",10
   147 00000191 736F20646573656164-
   148 0000019A 6F207365206C6F6772-
   149 000001A3 6F2073617469736661-
   150 000001AC 63746F7269616D656E-
   151 000001B5 74650A             
   152                                  lenListo:	equ	$-msgListo
   153                                  
   154                                  
   155                                  section .text
   156                                          global _start
   157                                          
   158                                          
   159                                  _start:
   160                                  
   161                                  prompt: ; ciclo que imprime el ">>" para recibir argumentos
   162 00000000 B9[00000000]                    mov     ecx, msjprompt 
   163 00000005 BA0F000000                      mov     edx, lenprompt
   164 0000000A E84A060000                      call    DisplayText
   165                                  			
   166 0000000F B9[02000000]            		mov ecx,bufferArg	; recibir los argumentos
   167 00000014 BAC8000000              		mov edx, lenArg
   168 00000019 E867060000              		call ReadText
   169 0000001E B900000000              		mov ecx,0; contador
   170 00000023 EB00                    		jmp .verificarArg1	
   171                                  		
   172                                  .verificarArg1:
   173 00000025 BE00000000              		mov esi,0
   174 0000002A 8A81[02000000]          	    mov al,byte[bufferArg+ecx]		; guarda la letra del comando, con el contador se sabe cual es
   175 00000030 8881[FC000000]          	    mov byte[bufferArg1+ecx],al; mueve a un buffer la primera letra en el byte correspondiente
   176 00000036 80B9[02000000]20        	    cmp byte[bufferArg+ecx]," "; verifica si hay un espacio
   177 0000003D 740C                    	    je .verificarArg2	; si es asi deberia estar el primer comando listo, la instruccion
   178 0000003F 80B9[02000000]0A        		cmp byte[bufferArg+ecx],10	;compara si hay un enter o sea solo seria un comando, solo sirve con salir
   179 00000046 7469                    	    je  verificarTipoArg1		; si es asi verifica el unico comando
   180 00000048 41                      	    inc ecx							; incrementa el contador
   181 00000049 EBDA                    	   jmp .verificarArg1		; vuelve al proceso
   182                                  	   
   183                                  .verificarArg2: ; guarda el segundo argumento el el bufferArg2
   184 0000004B BF00000000              	mov edi,0	; para verificar el --ayuda mas adelante
   185 00000050 41                      	inc ecx		; incrementa el contador de lineas para que siga el segundo argumento, habia quedado en el espacio vacio
   186 00000051 8A81[02000000]          	mov al,byte[bufferArg+ecx]	; al contiene el byte de una letra del segundo argumento
   187 00000057 8886[CA000000]          	mov byte[bufferArg2+esi],al	; la guarda en el buffer para el segundo argumento
   188 0000005D 80B9[02000000]20        	cmp byte[bufferArg+ecx]," "	; compara si hay un espacio vacio
   189 00000064 740C                    	je	.verificarArg3			; si es asi significaria que existe un 3er argumento, entonces salta guardarlo
   190 00000066 80B9[02000000]0A        	cmp byte[bufferArg+ecx],10	; compara si hay un enter
   191 0000006D 7442                    	je verificarTipoArg1		;si hay un enter salta a ver que tipo de instruccion se dio
   192 0000006F 46                      	inc esi						;incrementa la posicion donde va la letra del bufferArg2
   193 00000070 EBD9                    	jmp .verificarArg2			; vuelve al ciclo a verificar otra letra
   194                                  	
   195                                  .verificarArg3:					;guarda el 3er arguemtento en el buffer correspondiente bufferArg3
   196 00000072 41                      	inc ecx						; incrementa el contador de la instruccion para asi caer en el 3er parametro
   197 00000073 8A81[02000000]          	mov al,byte[bufferArg+ecx]	;guarda el la letra correspondiente del 3er argumento
   198 00000079 3C20                    	cmp al," "					; la compara con un espacio vacio
   199 0000007B 7419                    	je .reiniciarCont			; si es asi reinicia un contador para verificar el 4to argumento que seria despues del " "(espacio vacio)
   200 0000007D 80B9[02000000]0A        	cmp byte[bufferArg+ecx],10	;compara si un enter	
   201 00000084 742B                    	je verificarTipoArg1		; si es asi va a ver que tipo de instruccion se paso
   202 00000086 8887[07010000]          	mov byte[bufferArg3+edi],al	;guarda el 3er argumento en un buffer que solo va a contener ese argumento
   203 0000008C C687[08010000]00        	mov byte[bufferArg3+edi+1],0; va guardando un 0 siempre adelante, esto para cuando llegue al final exista un null de mas por si es el nombre de un archivo, se necesita ese null
   204 00000093 47                      	inc edi						; incrementa la letra del bufferArg3
   205 00000094 EBDC                    	jmp .verificarArg3			;vuelve al ciclo
   206                                  	
   207                                  .reiniciarCont:	
   208 00000096 BF00000000              	mov edi,0	; reinicia un contador para poder usarlo al verificar el argumeto4
   209 0000009B EB00                    	jmp .verificarArg4	; salta a verificar el argumento 4
   210                                  .verificarArg4:		;guardar el argumento 4 en un buffer por aparte bufferArg4
   211 0000009D 41                      	inc ecx			; incrementa el contador de la instruccion para asi caer en el 4to parametro
   212 0000009E 8A81[02000000]          	mov al,byte[bufferArg+ecx]; guarda la letra de el 4 argumento
   213 000000A4 8887[39010000]          	mov byte[bufferArg4+edi],al; la guarda en el bufferArg4, que solo contiene el 4to argumento
   214 000000AA 3C0A                    	cmp al,10					; compara, si hay un enter
   215 000000AC 7403                    	je verificarTipoArg1		; si es asi salta a ver que tipo de instruccion es
   216 000000AE 47                      	inc edi							; incrementa la letra del bufferArg4
   217 000000AF EBEC                    	jmp .verificarArg4				;vuelve al ciclo
   218                                  	
   219                                  verificarTipoArg1:				; verifica el comando, lo que se hace es comparar la primera letra de la instruccion
   220                                  								;y de ahi va a verificar cada instruccion por aparte dependiendo de cual se escoge
   221                                  								; si es comparar o copiar que usan la misma letra inicial,se compara primero con copiar 
   222                                  								; despues con comparar
   223                                  								
   224                                  								
   225 000000B1 83F900                  	cmp ecx,0	; si solo se dio enter		
   226 000000B4 0F8446FFFFFF            	je prompt	; salte de una vez al error
   227 000000BA C686[CA000000]00        	mov byte [bufferArg2+esi],0 ; guarda un 0(null) al final del 2do argumento en caso de que sea el nombre de un archivo es importante
   228 000000C1 B901000000              	mov ecx,1						; contador en 1 para despues compara cada comando 1 por 1
   229 000000C6 803D[FC000000]73        	cmp byte[bufferArg1],"s"	; si es "s" solo podria ser salir, se verifica eso
   230 000000CD 7435                    	je verificarSalir				
   231 000000CF 803D[FC000000]6D        	cmp byte[bufferArg1],"m"	; si es "m" solo seria mostrar entonces se verifica eso
   232 000000D6 744A                    	je verificarMostrar
   233 000000D8 803D[FC000000]62        	cmp byte[bufferArg1],"b"	; si es "b" solo seria borrar entonces se verifica eso
   234 000000DF 0F8493000000            	je verificarBorrar
   235 000000E5 803D[FC000000]72        	cmp byte[bufferArg1],"r" 	;si es  "r" solo seria renombrar entonces se verifica eso 
   236 000000EC 0F8432010000            	je verificarRenombrar
   237 000000F2 803D[FC000000]63        	cmp byte[bufferArg1],"c"	; si es  "c" podria ser  copiar o comparar entonces se verifican los dos, primero copiar
   238 000000F9 0F84E6010000            	je verificarCopiar
   239 000000FF E9EA040000              	jmp Error						; si no es ninguno va al mensaje de error
   240                                  
   241                                  verificarSalir:				; verifica si se escribio salir
   242 00000104 8A81[39000000]          	mov al,byte[msgSalir+ecx]	
   243 0000010A 3881[FC000000]          	cmp byte[bufferArg1+ecx],al	; va comparando el primer parametro con el msgSalir = "salir" asi  se sabe si se escribio eso
   244 00000110 0F85D8040000            	jne Error		; si no es asi salte a mensaje de error
   245 00000116 83F904                  	cmp ecx,4			; compara contador con 4 , la cantidad de letras de salir despue de la "s"
   246 00000119 0F8431050000            	je fin				; se escribio salir.... salga, salte a fin
   247 0000011F 41                      	inc ecx
   248 00000120 EBE2                    	jmp verificarSalir;vuelve al ciclo comparando otra letra
   249                                  
   250                                  verificarMostrar:	; cuenta las letras de mostrar, las compara con un msg que dice "mostrar"
   251 00000122 8A81[10000000]          	mov al,byte[msgMostar+ecx]
   252 00000128 3881[FC000000]          	cmp byte[bufferArg1+ecx],al	
   253 0000012E 0F85BA040000            	jne Error	; si un byte no cooncuerda da error
   254 00000134 83F907                  	cmp ecx,7	; si llego a 7 significa que si sirve
   255 00000137 7403                    	je .ayudaMostrar		; salta a ayuda
   256 00000139 41                      	inc ecx	;si no aumenta el contador de bytes, cambia de letra
   257 0000013A EBE6                    	jmp verificarMostrar	; y vuelve al ciclo
   258                                  	
   259                                  .ayudaMostrar:; verificar si el segundo argumento es --ayuda
   260 0000013C 8A87[81000000]          	mov al,byte[msgAyuda+edi]	 
   261 00000142 3887[CA000000]          	cmp byte[bufferArg2+edi],al	; compara letra con letra
   262 00000148 751A                    	jne .mostrarArchivo	; si no son iguales se va a ver si es un archivo
   263 0000014A 47                      	inc edi					;incrementa el contador del buffer para guardar el segundo argumento
   264 0000014B 83FF08                  	cmp edi,8	; compara con  --ayuda
   265 0000014E 75EC                    	jne .ayudaMostrar		; vuelve 
   266                                  	
   267 00000150 BB[1F010000]            	mov ebx,mostrarAyuda	; abre el archivo de ayuda, se define su nombre en la .data como mostrarAyuda
   268 00000155 B900000000              	mov ecx,0
   269 0000015A E833050000              	call Open		; subrutina que abre el archivo
   270                                  		
   271 0000015F E9B9040000              	jmp leerArchivo	; lo lee e imprime 
   272                                  
   273                                  
   274                                  
   275                                  .mostrarArchivo:			
   276 00000164 BB[CA000000]            	mov		ebx,bufferArg2	; mostrar el archivo que se escogio pasando como argumento el nombre
   277 00000169 B900000000              	mov		ecx, 0		
   278 0000016E E81F050000              	call Open	; se abre el archivo 
   279 00000173 E9A5040000              	jmp leerArchivo		; y lo lee e imprime
   280                                  
   281                                  
   282                                  
   283                                  verificarBorrar:
   284 00000178 8A81[18000000]          	mov al,byte[msgBorrar+ecx]	
   285 0000017E 3881[FC000000]          	cmp byte[bufferArg1+ecx],al	; va comparando el primer parametro con el msgBorrar = "borrar" asi  se sabe si se escribio eso
   286 00000184 0F8564040000            	jne Error		; si no es asi salte a mensaje de error
   287 0000018A 83F906                  	cmp ecx,6			; compara contador con 4 , la cantidad de letras de borrar
   288 0000018D 7403                    	je .pordonde			; se escribio salir.... salga, salte a fin
   289 0000018F 41                      	inc ecx
   290 00000190 EBE6                    	jmp verificarBorrar
   291                                  	
   292                                  .pordonde:; aqui se sabe si es una llamada al --ayuda o si es --forzado
   293 00000192 BE00000000              	mov esi,0	
   294 00000197 BF00000000              	mov edi,0
   295 0000019C 803D[07010000]00        	cmp byte[bufferArg3],0	; compara el 3er argumento con vacio
   296 000001A3 7402                    	je .ayudaBorrar			; si es asi verifica si lo que dice es --ayuda
   297 000001A5 EB28                    	jmp .forzado			; else: va ver si dice --forzado
   298                                  	
   299                                  .ayudaBorrar:
   300 000001A7 8A87[81000000]          	mov al,byte[msgAyuda+edi]; mensaje que dice --ayuda
   301 000001AD 3887[CA000000]          	cmp byte[bufferArg2+edi],al	; compara letra con letra, con el argumento 2.... bufferArg2
   302 000001B3 7534                    	jne .confirmarBorrarArchivo	; si no son iguales se va a ver si es un archivo
   303 000001B5 47                      	inc edi					;incrementa el contador del buffer para guardar el segundo argumento
   304 000001B6 83FF08                  	cmp edi,8	; compara con  --ayuda
   305 000001B9 75EC                    	jne .ayudaBorrar		; vuelve 
   306 000001BB BB[EF000000]            	mov ebx,borrarAyuda	; abre el archivo de ayuda, se define su nombre en la .data como mostrarAyuda
   307 000001C0 B900000000              	mov ecx,0
   308 000001C5 E8C8040000              	call Open		; subrutina que abre el archivo
   309 000001CA E94E040000              	jmp leerArchivo
   310                                  
   311                                  .forzado:		; ve  si dice forzado, ya se sabe que existe un 3er argumento, entonces si no dice el va a error 
   312 000001CF 83FE09                  	cmp esi,9		; compara el indice de letras con 10 
   313 000001D2 7432                    	je  .borrarArchivo	; si llego a 10 significa que dice lo mismo
   314 000001D4 8A86[77000000]          	mov al,byte[msgForzado+esi]	; 
   315 000001DA 3886[07010000]          	cmp byte[bufferArg3+esi],al; compara el 3er argumento con el msgForzado: "--forzado",10
   316 000001E0 0F8508040000            	jne Error	; si no son iguales vaya a error
   317 000001E6 46                      	inc esi	; incrementa el indice de letras
   318 000001E7 EBE6                    	jmp .forzado	; vuelve al ciclo con la otra letra
   319                                  	
   320                                  		
   321                                  .confirmarBorrarArchivo:
   322 000001E9 E878040000              	call Confirmacion; llama al mensaje de confirmacion
   323 000001EE 48                      	dec eax ; eliminar el enter, se desea validaar, que si se pone "s" borre pero si se pone "sasdasd" no lo haga
   324 000001EF 83F801                  	cmp eax,1; si la respuesta es mas larga de 1 digito da error
   325 000001F2 0F85F6030000            	jne Error 	
   326 000001F8 803D[00000000]73        	cmp byte[buffConfirmacion],"s"; si dice "S"
   327 000001FF 7405                    	je .borrarArchivo	; salta a borrar el archivo
   328 00000201 E9FAFDFFFF              	jmp prompt; si dice "n" vuelve al prompt
   329                                  	
   330                                  .borrarArchivo:	;borrar e archivo
   331 00000206 BB[CA000000]            		mov ebx, bufferArg2	; mueve al ebx el nombre del archivo
   332 0000020B E89A040000              		call Remove			; se llama a remove que lo elimina
   333 00000210 EB00                    		jmp .testiarBorrado	; y revisa si se borro correctamente
   334                                  .testiarBorrado:
   335 00000212 85C0                    		test eax, eax
   336 00000214 0F88A5030000            		js ErrorNoArchivo	;si no existe el archivo lanza un mensaje de Error
   337 0000021A E893040000              		call CleanBssData	; limpia todos los buffers
   338 0000021F E97B030000              		jmp Listo			; vuelve al prompt
   339                                  	
   340                                  verificarRenombrar:	; verifica si dice renombrar el primer argumento
   341 00000224 8A81[FC000000]          	mov al,byte[bufferArg1+ecx]	
   342 0000022A 3A81[1F000000]          	cmp al,byte[msgRenombrar+ecx]; compara el argumento1 con el msgRenombrar: renombrar
   343 00000230 0F85B8030000            	jne Error			; si no es igual va a error
   344 00000236 41                      	inc ecx				; incrementa el indice que marca la letra
   345 00000237 83F90A                  	cmp ecx,10			; lo compara con 10 
   346 0000023A 7402                    	je .pordonde		; si es asi, ya se sabe que dice renombrar, entonces salta a ver que tipo de instrucciones le siguen
   347 0000023C EBE6                    	jmp verificarRenombrar; vuelve al ciclo
   348                                  	
   349                                  .pordonde:
   350 0000023E 803D[CA000000]00        	cmp byte[bufferArg2],0	; ver si existe segundo argumento
   351 00000245 0F84A3030000            	je Error; si no da error
   352 0000024B 803D[07010000]00        	cmp byte[bufferArg3],0	; ve si hay 3r argumento
   353 00000252 740B                    	je .ayudaRenombrar		; si no es asi va a verificar si se llamo a --ayuda
   354 00000254 803D[39010000]00        	cmp byte[bufferArg4],0	; ve si hay 4to argumento
   355 0000025B 744D                    	je .cambiarNombreConfirmacion;si no hay entonces no se estaria llamando --forzado por lo que salta a confirmar la accion
   356 0000025D EB31                    	jmp .forzarRenombrar	;si no se cumple nada , salta a revisar que diga --forzado
   357                                  
   358                                  .ayudaRenombrar:; verifica si hay un --ayuda en vez de algun nombre de archivo
   359 0000025F BE00000000              	mov esi,0	
   360 00000264 8A87[81000000]          	mov al,byte[msgAyuda+edi]	
   361 0000026A 3A87[CA000000]          	cmp al,byte[bufferArg2+edi]	; compara el el argumento2 con el msgAyuda = "--ayuda",10
   362 00000270 0F8578030000            	jne Error		; si no son iguales va a error
   363 00000276 47                      	inc edi			; incrementa el indice de letra
   364 00000277 83FF08                  	cmp edi,8		; lo compara,con 8 la cantidad de --ayuda,10
   365 0000027A 75E3                    	jne .ayudaRenombrar; si no son iguales vuelve al ciclo
   366                                  	
   367                                  	;ESTO SUCEDE SI SE CUMPLE EL CICLO(que diga --ayuda)
   368 0000027C BB[D5000000]            	mov ebx,renombrarAyuda; abre el archivo de ayuda, se define su nombre en la .data como renombrarAyuda
   369 00000281 B900000000              	mov ecx,0		;read only
   370 00000286 E807040000              	call Open		; subrutina que abre el archivo
   371 0000028B E98D030000              	jmp leerArchivo	; salta a la ruta que lee e imprime una archivo 
   372                                  	
   373                                  .forzarRenombrar:		; ve si dice verificado el 4to argumento
   374 00000290 8A87[77000000]          	mov al,byte[msgForzado+edi]	
   375 00000296 3A87[39010000]          	cmp al,byte[bufferArg4+edi]; va comparando el 4to argumento con el msgForzado:"--forzado",10
   376 0000029C 0F854C030000            	jne Error	; si no son iguales va a error
   377 000002A2 83FF09                  	cmp edi,9	; lo compara con 9 la cantidad de digitos,
   378 000002A5 7421                    	je .cambiarNombre; si es asi, se llego al final con exito
   379 000002A7 47                      	inc edi			;aumenta el indice de letras
   380 000002A8 EBE6                    		jmp .forzarRenombrar; vuelve al ciclo
   381                                  
   382                                  
   383                                  .cambiarNombreConfirmacion:	; confirmar que se desea cambiar el nombre
   384 000002AA E8B7030000              	call Confirmacion	; llama al confirmacion
   385 000002AF 48                      	dec eax				;borra el enter de la respuesta
   386 000002B0 83F801                  	cmp eax,1			; compara con 1
   387 000002B3 0F8535030000            	jne Error			; si no es 1 digito da error	
   388 000002B9 803D[00000000]73        	cmp byte[buffConfirmacion],"s"; compara con "s" 
   389 000002C0 0F853AFDFFFF            	jne prompt				; si no es asi va al prompt
   390 000002C6 EB00                    	jmp .cambiarNombre		; si es se procede a cambiar el nombre del archivo
   391                                  .cambiarNombre:	
   392 000002C8 BB[CA000000]            	mov ebx,bufferArg2	;nombre del archivo
   393 000002CD B9[07010000]            	mov ecx,bufferArg3	; nuevo nombre del archivo
   394 000002D2 E8C3030000              	call Rename			; llama a la funcion que renombra con esos 2 parametros de arriba
   395 000002D7 83F800                  	cmp eax,0			; compara el eax, 0 si no es 0 significa que hubo error al hacer el proceso de renombrado
   396 000002DA 0F84BF020000            	je Listo			; si son iguales vuelve al prompt
   397 000002E0 E9DA020000              	jmp ErrorNoArchivo	; si no le avisa al usario que algo paso, que el archivo no existe
   398                                  	
   399                                  verificarCopiar:				; verificar si se escribio la instruccion copiar
   400 000002E5 8A81[32000000]          	mov al,byte[msgCopiar+ecx]	;
   401 000002EB 3881[FC000000]          	cmp byte[bufferArg1+ecx],al	; compara el argumento1  con el msgCopiar: "copiar "
   402 000002F1 0F85AF000000            	jne verificarComparar; si no son iguales verifica comparar que es el otro que empieza con "c"
   403 000002F7 83F906                  	cmp ecx,6			; compara el indice de letras con 6
   404 000002FA 7403                    	je .pordonde		; si es asi significa que si dice copiar y se va a ver que tipo de argumentos le dan
   405 000002FC 41                      	inc ecx				; incrementa el indice de letras
   406 000002FD EBE6                    	jmp verificarCopiar; vuelve al ciclo
   407                                  	
   408                                  .pordonde:
   409 000002FF 803D[CA000000]00        	cmp byte[bufferArg2],0	; ver si existe segundo argumento
   410 00000306 0F84E2020000            	je Error				;si no existe va a error
   411 0000030C 803D[07010000]00        	cmp byte[bufferArg3],0	; ver si existe 3er argumento 
   412 00000313 740B                    	je .ayudaCopiar			; si no es asi verifica si dice --ayuda 
   413 00000315 803D[39010000]00        	cmp byte[bufferArg4],0	; ver si existe 4to argumento
   414 0000031C 744D                    	je .copiarConfirmacion	; si no existe va a preguntar si se desea continuar con la accion
   415 0000031E EB31                    	jmp .forzarCopiar		;salte a ver si dice forzado, ya que el 4to argumento no es vacio y solo contiene el --forzado opcionalmente
   416                                  	
   417                                  .ayudaCopiar:		;ver si dice --ayuda
   418 00000320 BE00000000              	mov esi,0	
   419 00000325 8A87[81000000]          	mov al,byte[msgAyuda+edi]
   420 0000032B 3A87[CA000000]          	cmp al,byte[bufferArg2+edi]; compara el argumento2 con msgAyuda: "--ayuda",10
   421 00000331 0F85B7020000            	jne Error				; si no son iguales va a error
   422 00000337 47                      	inc edi					;incrementa el indice de letras
   423 00000338 83FF08                  	cmp edi,8				; compara el indice de letras con 8 la cantidad de digitos de --ayuda,10 
   424 0000033B 75E3                    	jne .ayudaCopiar		;si no es 8 vuelve al ciclo
   425 0000033D BB[BE000000]            	mov ebx,copiarAyuda; abre el archivo de ayuda, se define su nombre en la .data como renombrarAyuda
   426 00000342 B900000000              	mov ecx,0		;SOLO lectura
   427 00000347 E846030000              	call Open		; subrutina que abre el archivo
   428 0000034C E9CC020000              	jmp leerArchivo	; lee e imprime el mensaje
   429                                  		
   430                                  .forzarCopiar: ; verifica si el 4to argumento dice  --forzado
   431 00000351 8A87[77000000]          	mov al,byte[msgForzado+edi]
   432 00000357 3A87[39010000]          	cmp al,byte[bufferArg4+edi]	; compara el cuarto argumento con el msgForzado:--forzado,10
   433 0000035D 0F858B020000            	jne Error		; si no es asi da error
   434 00000363 83FF09                  	cmp edi,9		; compara el indice de letras con 9 que es la cantidad de digitos de msgForzado
   435 00000366 7421                    	je .copiar		; si es asi se llego al final, entonces se copia el archivo
   436 00000368 47                      	inc edi			; incrementa el indice de letras
   437 00000369 EBE6                    	jmp .forzarCopiar	; vuelve al ciclo
   438                                  
   439                                  .copiarConfirmacion:	; confirmar si se desea copiar
   440 0000036B E8F6020000              	call Confirmacion	; llama a la subrutina que pregunta si se desea continuar con la accion, la respuesta se guarda en el eax
   441 00000370 48                      	dec eax			; borra el enter de la respuesta
   442 00000371 83F801                  	cmp eax,1	; compara con 1 o sea que sea un digito nada mas
   443 00000374 0F8574020000            	jne Error	; si no es asi da error
   444 0000037A 803D[00000000]73        	cmp byte[buffConfirmacion],"s"	;comparara si dice "s"
   445 00000381 0F8579FCFFFF            	jne prompt					;si no dice "s" entonces vuelve al prompt
   446 00000387 EB00                    	jmp .copiar				; si dice "s" entonces salta a el proceso que copia el archivo
   447                                  .copiar:
   448 00000389 BB[CA000000]            	mov ebx,bufferArg2	; guarda el nombre del archivo
   449 0000038E B9[07010000]            	mov ecx,bufferArg3	; y el nombre del archivo nuevo, el copiado
   450 00000393 E80A030000              	call Copy			; llama a la subrutina que copia archivos
   451 00000398 83F800                  	cmp eax,0			; si el eax da 0 ,todo ocurrio bien, si no entonces no existia el archivo	
   452 0000039B 0F84FE010000            	je Listo			;si es 0  vuelve al prompt
   453 000003A1 E919020000              	jmp ErrorNoArchivo	; si  no da un mensaje al usuario de que no existe tal archivo
   454                                  	
   455                                  	
   456                                  	
   457                                  verificarComparar:	; verificar si dice comparar la instruccion(primer argumento)
   458 000003A6 8A81[29000000]          	mov al,byte[msgCompara+ecx]
   459 000003AC 3A81[FC000000]          	cmp al,byte[bufferArg1+ecx]	; compara el primer argumento, con el msgComparar: "comparar "
   460 000003B2 0F8536020000            	jne Error			; si no son iguales da error	
   461 000003B8 83F908                  	cmp ecx,8			;compara el indice de letras con 8, la cantidad de digitos del msgComparar
   462 000003BB 7403                    	je .pordonde		; si es asi va a ver que tipo de argumentos siguen despues de el
   463 000003BD 41                      	inc ecx				; incrementaa el indice de digitos	
   464 000003BE EBE6                    	jmp verificarComparar	; vuelve al ciclo con el siguiente digito 
   465                                  
   466                                  .pordonde:
   467 000003C0 803D[CA000000]00        	cmp byte[bufferArg2],0	; ver si existe segundo argumento
   468 000003C7 0F8421020000            	je Error				;si no existe da error
   469 000003CD 803D[07010000]00        	cmp byte[bufferArg3],0	; ver si existe 3er argumento
   470 000003D4 740E                    	je .ayudaComparar		; si no existe va a ver si el segundo dice --ayuda
   471 000003D6 803D[39010000]00        	cmp byte[bufferArg4],0	; ver si existe 4to argumento
   472 000003DD 7436                    	je .compararConfirmacion; si no existe va a confirmar la accion
   473 000003DF E90A020000              	jmp Error				; si no se cumple nada da error
   474                                  
   475                                  .ayudaComparar:			;ver si dice --ayuda el segundo argumento
   476 000003E4 BE00000000              	mov esi,0
   477 000003E9 8A87[81000000]          	mov al,byte[msgAyuda+edi]
   478 000003EF 3A87[CA000000]          	cmp al,byte[bufferArg2+edi]	; compara el 2do argumento con msgAyuda: "--ayuda",10
   479 000003F5 0F85F3010000            	jne Error	; si no son iguales da error
   480 000003FB 47                      	inc edi			; incrementa el indice de letras
   481 000003FC 83FF08                  	cmp edi,8			;compara si es 8 o sea la cantidad de digitos del msgAyuda
   482 000003FF 75E3                    	jne .ayudaComparar	;si no es asi vuelve al ciclo
   483 00000401 BB[06010000]            	mov ebx,compararAyuda; abre el archivo de ayuda, se define su nombre en la .data como compararaAyuda
   484 00000406 B900000000              	mov ecx,0		; solo lectura
   485 0000040B E882020000              	call Open		; subrutina que abre el archivo
   486 00000410 E908020000              	jmp leerArchivo	; lee e imprime el archivo
   487                                  
   488                                  .compararConfirmacion:	; confirmar que se desea continuar con la accion
   489 00000415 E84C020000              	call Confirmacion	; subrutina que pregunta si se desea continuar, el largo de su respuesta queda en el eax
   490 0000041A 48                      	dec eax	;borra el enter 
   491 0000041B 83F801                  	cmp eax,1; compara el largo de la respuesta con 1 
   492 0000041E 0F85CA010000            	jne Error; si no es asi da error
   493 00000424 803D[00000000]73        	cmp byte[buffConfirmacion],"s"; compara la respuesta con "s"
   494 0000042B 0F85CFFBFFFF            	jne prompt	; si no es asi vuelve al prompt
   495 00000431 EB00                    	jmp .AbrirArchivos	; si es "s" salta a abrir ambos archivo 
   496                                  	
   497                                  
   498                                  	
   499                                  .AbrirArchivos:
   500 00000433 BB[CA000000]            	mov ebx,bufferArg2 ; nombre del primer archivo
   501 00000438 B900000000              	mov ecx,0	; solo lectura
   502 0000043D E850020000              	call Open	; llama a la funcion que lo abre
   503 00000442 3D00F0FFFF              	cmp eax, -4096 ; Existe?
   504 00000447 0F8772010000            	ja ErrorNoArchivo	; si no da erro
   505 0000044D 89C3                    	mov		ebx, eax			; lo lee 
   506 0000044F B9[21070000]            	mov		ecx, File1			; y lo guarda en el file1
   507 00000454 BADC050000              	mov		edx, lenFile1
   508 00000459 B803000000              	mov		eax, sys_read
   509 0000045E CD80                    	int 	80h			
   510                                  	
   511 00000460 BB[07010000]            	mov ebx,bufferArg3	; nombre del segundo archivo
   512 00000465 B900000000              	mov ecx,0			;solo lectura
   513 0000046A E823020000              	call Open			;subrutrina que abre el archivo
   514 0000046F 3D00F0FFFF              	cmp eax, -4096 ; Existe?
   515 00000474 0F8774010000            	ja Error	; si no da error
   516 0000047A 89C3                    	mov		ebx, eax			; lo lee 
   517 0000047C B9[FD0C0000]            	mov		ecx, File2		; lo guarda en el File2
   518 00000481 BADC050000              	mov		edx, lenFile2
   519 00000486 B803000000              	mov		eax, sys_read	
   520 0000048B CD80                    	int 	80h	
   521 0000048D B801000000              	mov eax,1	;contador de lineas
   522 00000492 BB00000000              	mov ebx,0	;indice de bytes file1
   523 00000497 B900000000              	mov ecx,0	;indice de bytes file2
   524 0000049C BE00000000              	mov esi,0	
   525 000004A1 BF00000000              	mov edi,0	; indice de bytes de linea1 y linea2
   526 000004A6 EB00                    	jmp .ciclo
   527                                  
   528                                  .ciclo:			;ciclo que guarda la filas en un buffer, linea1
   529 000004A8 8AB3[21070000]          	mov dh,byte[File1+ebx]
   530 000004AE 88B7[D9120000]          	mov byte[linea1+edi],dh	; mueve a la linea1 lo que hay en el File1(		primer archivo)
   531 000004B4 80BF[D9120000]00        	cmp byte[linea1+edi],0	; compara el byte de la linea1 con 0, o sea si se llego al final del archivo
   532 000004BB 0F84CA000000            	je .finArchivos			; si es asi imprime que se termino un archivo
   533 000004C1 80BF[D9120000]0A        	cmp byte[linea1+edi],10	; compara el byte de la linea1 con 10, un enter
   534 000004C8 7404                    	je .reset	; si es asi deja de guardar porque ahi termina esa linea
   535 000004CA 43                      	inc ebx; incrementa el indice de bytes del archivo1 completo
   536 000004CB 47                      	inc edi	; incrementa el indice de bytes de la linea1
   537 000004CC EBDA                    	jmp .ciclo; vuelve al ciclo
   538                                  .reset:
   539 000004CE BF00000000              	mov edi,0	; reinicia el indice de bytes de la linea1 para usarlo en la linea2
   540 000004D3 EB00                    	jmp .ciclo2	; salta al ciclo2 que hace lo mismo del ciclo pero con el segundo archivo
   541                                  		
   542                                  .ciclo2:
   543 000004D5 8A91[FD0C0000]          	mov dl,byte[File2+ecx]	
   544 000004DB 8897[69140000]          	mov byte[linea2+edi],dl	; guarda en la linea2 lo que hay en el archivo2
   545 000004E1 80BF[69140000]00        	cmp byte[linea2+edi],0	; compara si hay un 0 en la linea 2 significa que el archivo termino
   546 000004E8 0F849D000000            	je .finArchivos	; si es asi sale a un proceso que envia un mensaje que el archivo termino 
   547 000004EE 80BF[69140000]0A        	cmp byte[linea2+edi],10	; compara el byte con 10 , enter
   548 000004F5 7404                    	je .comparar			;si sucede va a comparar linea1 y linea2 byte por byte
   549 000004F7 41                      	inc ecx					; incrementa el indice de bytes del archivo2
   550 000004F8 47                      	inc edi					;incrementa el 	indice de bytes de la linea2
   551 000004F9 EBDA                    	jmp .ciclo2				;vuelve al ciclo
   552                                  	
   553                                  .comparar:
   554                                  
   555 000004FB 8A96[D9120000]          	mov dl,byte[linea1+esi]; 
   556 00000501 8AB6[69140000]          	mov dh,byte[linea2+esi]	
   557 00000507 38F2                    	cmp dl,dh				; compara linea1 con linea2 , byte por byte
   558 00000509 750D                    	jne	.imprimir			; si no son iguales , salte a imprimir que imprime que existe diferencia
   559 0000050B 80FA0A                  	cmp dl,10				; compara el byte actual de linea1 con 10 o sea enter
   560 0000050E 743D                    	je .buena				; si es asi salte a buena
   561 00000510 80FE0A                  	cmp dh,10				; compara el byte actual de linea2 con 10 o sea ente
   562 00000513 7438                    	je .buena				; si es asi salte a buena
   563 00000515 46                      	inc esi					;incremena el indice de bytes de linea1 y linea2
   564 00000516 EBE3                    	jmp .comparar			; vuelve al ciclo con el siguiente byte	
   565                                  	
   566                                  
   567                                  .imprimir:	; imprimir la la linea en la que hay diferencia
   568                                  	; GUARDA LOS REGISTROS QUE SIRVEN DE CONTADORES DE LINEAS Y POSICIONES EN LOS ARCHIVOS
   569 00000518 56                      	push esi
   570 00000519 50                      	push eax
   571 0000051A 53                      	push ebx
   572 0000051B 51                      	push ecx
   573 0000051C E8E8010000              	call ImprimirNumero	; llama a imprimir numero, que imprime lo que este en el eax,
   574 00000521 B9[D9120000]                mov ecx,linea1	; imprime lo que dice la linea1 que es diferente a la linea2
   575 00000526 BAC8000000                  mov edx,200
   576 0000052B E829010000                  call DisplayText
   577 00000530 B9[69140000]                mov ecx,linea2	; imprime lo que dice la linea2 que es diferente a la linea1
   578 00000535 BAC8000000                  mov edx,200
   579 0000053A E81A010000                  call DisplayText
   580                                      ;Limpia registros
   581 0000053F 31C0                        xor eax,eax	
   582 00000541 31DB                        xor ebx,ebx
   583 00000543 31C9                        xor ecx,ecx
   584 00000545 31F6                        xor esi,esi
   585                                      ; SACA LOS CONTADORES DE LINEAS Y POSICIONES EN LOS ARCHIVOS
   586 00000547 59                          pop ecx
   587 00000548 5B                          pop ebx
   588 00000549 58                          pop eax	
   589 0000054A 5E                          pop esi
   590 0000054B EB0C                    	jmp .fciclo; salta al final del ciclo
   591                                  
   592                                  .buena:
   593 0000054D 80FE0A                  	cmp dh,10; compara el byte de la linea1,con un enter 
   594 00000550 75C6                    	jne .imprimir; si no es asi imprime
   595 00000552 80FA0A                  	cmp dl,10	; compara el byte de la linea2 con un enter
   596 00000555 75C1                    	jne .imprimir; si no es asi lo imprime
   597 00000557 EB00                    	jmp .fciclo	; salta al final del ciclo
   598                                  	
   599                                  .fciclo:
   600 00000559 41                      	inc ecx	;incrementa el indice de bytes del archivo2
   601 0000055A 43                      	inc ebx; incrementa el indice de bytes de archivo1
   602 0000055B 40                      	inc eax	; incrementa la linea actual
   603                                  	;LOS GUARDA EN LA PILA
   604 0000055C 51                      	push ecx	
   605 0000055D 50                      	push eax
   606 0000055E 53                      	push ebx
   607                                  	;LIMPIA LINEA1 Y LINEA2
   608 0000055F 31C0                    	xor eax,eax	
   609 00000561 BF[D9120000]               	mov     edi, linea1
   610 00000566 B9C8000000              	mov     ecx, 200
   611 0000056B F3AA                        rep     stosb
   612 0000056D BF[69140000]               	mov     edi, linea2
   613 00000572 B9C8000000              	mov     ecx, 200
   614 00000577 F3AA                        rep    	 stosb
   615                                      ;LOS SACA DE LA PILA
   616 00000579 5B                          pop ebx
   617 0000057A 58                      	pop eax
   618 0000057B 59                          pop ecx
   619                                      ; contadores de lineas desde 0 
   620 0000057C BF00000000                  mov edi,0
   621 00000581 BE00000000                	mov esi,0
   622                                  ;	vuelve al ciclo
   623 00000586 E91DFFFFFF                  jmp .ciclo
   624                                  
   625                                  .finArchivos: ; si un archivo llega al final, lo imprime
   626 0000058B B9[3E000000]            	mov ecx,msgFinArchivos
   627 00000590 BA39000000              	mov edx,lenFinArchivos
   628 00000595 E8BF000000              	call DisplayText
   629 0000059A E961FAFFFF              	jmp prompt	; vuelve al prompt
   630                                  
   631                                  	
   632                                  	
   633                                  	
   634                                  	
   635                                  Listo:	; imprime que se logro bien el proceso deseado
   636 0000059F B9[88010000]            		mov ecx,msgListo
   637 000005A4 BA30000000              		mov edx,lenListo
   638 000005A9 E8AB000000              		call DisplayText
   639 000005AE BBC8000000              		mov ebx,lenArg
   640 000005B3 89D9                    		mov ecx,ebx
   641 000005B5 E8F8000000              		call CleanBssData
   642 000005BA E941FAFFFF              		jmp prompt
   643                                  	
   644                                  
   645                                  ErrorNoArchivo:		; mensaje de error pero de que no exise el archivo dado
   646 000005BF B9[54010000]            	mov ecx,msgErrorNoArchivo	; imprime mensaje de error
   647 000005C4 BA2F000000              	mov edx,lenErrorNoArchivo
   648 000005C9 E88B000000              	call DisplayText
   649 000005CE B9[0F000000]            	mov ecx,msgEnter
   650 000005D3 BA01000000              	mov edx,lenEnter
   651 000005D8 E87C000000              	call DisplayText
   652 000005DD BBC8000000              	mov ebx,lenArg	; mueve el largo de toda la instruccion 
   653 000005E2 89D9                    	mov ecx,ebx			; lo mueve al ecx
   654 000005E4 E8C9000000              	call CleanBssData	; llama subrutina para limpiar los buffers
   655 000005E9 E912FAFFFF              	jmp prompt	; vuelve al prompt
   656                                  Error:
   657 000005EE B9[37010000]            	mov ecx,msgError	; imprime mensaje de error
   658 000005F3 BA1D000000              	mov edx,lenError
   659 000005F8 E85C000000              	call DisplayText
   660 000005FD B9[0F000000]            	mov ecx,msgEnter
   661 00000602 BA01000000              	mov edx,lenEnter
   662 00000607 E84D000000              	call DisplayText
   663 0000060C BBC8000000              	mov ebx,lenArg	; mueve el largo del argumento
   664 00000611 89D9                    	mov ecx,ebx			; lo mueve al contador
   665 00000613 E89A000000              	call CleanBssData	; llama subrrutina que limpia buffers
   666 00000618 E9E3F9FFFF                  jmp prompt
   667                                  
   668                                  
   669                                  leerArchivo:	; leer e imprimir archivo
   670                                  
   671 0000061D 3D00F0FFFF              	cmp eax, -4096 ; Existe?
   672 00000622 779B                    	ja ErrorNoArchivo
   673 00000624 89C3                    	mov		ebx, eax			; lo lee 
   674 00000626 B9[45010000]            	mov		ecx, fileBuf		;lo guarda en el buffer del archivo
   675 0000062B BADC050000              	mov		edx, fileBufLen
   676 00000630 B803000000              	mov		eax, sys_read	
   677 00000635 CD80                    	int 	80h					
   678                                  	
   679 00000637 B9[45010000]            	mov ecx,fileBuf		; lo imprime
   680 0000063C BADC050000              	mov edx,fileBufLen
   681 00000641 E813000000              	call DisplayText	
   682 00000646 E867000000              	call CleanBssData; subrutina que limpia los buffers de la .bss
   683 0000064B E9B0F9FFFF              	jmp prompt		 ; y vuelve al prompt
   684                                  
   685                                  
   686                                  fin:  			; fin, cierra el programa
   687 00000650 B801000000                  mov     eax, sys_exit	
   688 00000655 31DB                        xor     ebx, ebx
   689 00000657 CD80                        int     80H  
   690                                  
   691                                      
   692                                      
   693                                  ;rutinas intermedias...
   694                                  
   695                                  ; desplega algo en la salida estándar. debe "setearse" lo siguiente:
   696                                  ; ecx: el puntero al mensaje a desplegar
   697                                  ; edx: el largo del mensaje a desplegar
   698                                  ; modifica los registros eax y ebx.
   699                                  DisplayText:
   700 00000659 B804000000                  mov     eax, sys_write
   701 0000065E BB01000000                  mov     ebx, stdout
   702 00000663 CD80                        int     80H 
   703 00000665 C3                          ret
   704                                      
   705                                  Confirmacion:		; imprime mensaje de confirmacion, y pide la respuesta, 
   706                                  ;	la respuesta queda en el buffer
   707                                  ;	en el eax queda el largo de la respuesta
   708 00000666 B9[89000000]            	mov ecx,msgConfirmacion
   709 0000066B BA35000000              	mov edx,lenConfirmacionMsg
   710 00000670 E8E4FFFFFF              	call DisplayText
   711 00000675 B9[00000000]            	mov ecx,buffConfirmacion
   712 0000067A BA02000000              	mov edx,lenConfirmacion
   713 0000067F E801000000              	call ReadText
   714 00000684 C3                      	ret
   715                                  
   716                                   
   717                                  
   718                                  ; lee algo de la entrada estándar.debe "setearse" lo siguiente:
   719                                  ; ecx: el puntero al buffer donde se almacenará
   720                                  ; edx: el largo del mensaje a leer
   721                                  ReadText:
   722 00000685 BB00000000                  mov     ebx, stdin
   723 0000068A B803000000                  mov     eax, sys_read
   724 0000068F CD80                        int     80H
   725 00000691 C3                          ret
   726                                      
   727                                  
   728                                  ; abre un archivo
   729                                  ;en el ebx, tiene que estar el nombre del archivo
   730                                  ;en el ecx tiene que venir el tipo de lectura	
   731                                  ;retorna el filedescriptor en el eax
   732                                  Open:
   733 00000692 B805000000              	mov eax,sys_open
   734 00000697 CD80                    	int 80H
   735 00000699 C3                      	ret 
   736                                  
   737                                  ;renombra un archivo
   738                                  ;ebx :nombre del archivo
   739                                  ;ecx: nuevo nombre del archivo
   740                                  ;retorna en el eax un 0 si fue exitoso el cambio de nombre, un -1 si hubo error
   741                                  Rename:
   742 0000069A B826000000              	mov eax,sys_rename
   743 0000069F CD80                    	int 80h
   744 000006A1 C3                      	ret
   745                                  	
   746                                  
   747                                  ;copiar un archivo
   748                                  ;ebx :nombre del archivo
   749                                  ;ecx: nuevo nombre del archivo
   750                                  ;retorna en el eax un 0 si fue exitoso el cambio de nombre, un -1 si hubo error	
   751                                  Copy:
   752 000006A2 B809000000              	mov eax,sys_link
   753 000006A7 CD80                    	int 80h
   754 000006A9 C3                      	ret
   755                                  ;elimina un archivo 
   756                                  ;ebx : nombre del archivo 
   757                                  ;retorna en el eax un 0 si fue exitoso el cambio de nombre, un -1 si hubo error	
   758                                  Remove:
   759 000006AA B80A000000              	mov eax, sys_unlink
   760 000006AF CD80                    	int 80h
   761 000006B1 C3                      	ret
   762                                  	
   763                                  ;subrutina que limpia todos los buffer que se utilizan
   764                                  ; usa la instruccion rep stosb
   765                                  ;edi, buffer 
   766                                  ;ecx: largo del buffer
   767                                  CleanBssData:
   768 000006B2 31C0                    	xor eax,eax
   769 000006B4 BF[00000000]            	mov 	edi,buffConfirmacion
   770 000006B9 B902000000              	mov 	ecx,lenConfirmacion
   771 000006BE F3AA                    	rep		stosb
   772 000006C0 BF[FC000000]            	mov 	edi,bufferArg1
   773 000006C5 B90B000000              	mov 	ecx,lenArg1
   774 000006CA F3AA                    	rep		stosb	
   775 000006CC BF[02000000]            	mov     edi, bufferArg
   776 000006D1 B9C8000000              	mov     ecx, lenArg
   777 000006D6 F3AA                        rep     stosb
   778 000006D8 BF[CA000000]            	mov     edi, bufferArg2
   779 000006DD B932000000              	mov     ecx, lenArg2
   780 000006E2 F3AA                        rep     stosb
   781 000006E4 BF[07010000]            	mov     edi, bufferArg3
   782 000006E9 B932000000              	mov     ecx, lenArg3
   783 000006EE F3AA                        rep     stosb
   784 000006F0 BF[39010000]               	mov     edi, bufferArg4
   785 000006F5 B90C000000              	mov     ecx, lenArg4
   786 000006FA F3AA                        rep     stosb
   787 000006FC BF[45010000]                mov     edi, fileBuf
   788 00000701 B9DC050000              	mov     ecx, fileBufLen
   789 00000706 F3AA                        rep     stosb
   790 00000708 C3                          ret
   791                                  ; imprimir numero
   792                                  ;imprime un numero, lo pasa a ascii
   793                                  ; el numero tiene que estar guardado en el eax
   794                                  ; modifica los registros eax,ebx,ecx,edx,esi,edi
   795                                  ImprimirNumero:
   796 00000709 B90A000000              	mov 	ecx,10			;
   797 0000070E 6631DB                  	xor	bx,bx			;limpiar registro para usalrlo como contador de digitos de 16bits
   798                                  
   799                                  .division:
   800 00000711 31D2                    	xor	edx,edx 	; limpia el registro edx
   801 00000713 F7F1                    	div	ecx		;efectua la division
   802 00000715 6652                    	push 	dx		; guarda en la pila el digito
   803 00000717 6643                    	inc 	bx		; contador+1
   804 00000719 85C0                    	test 	eax, eax	; fin del ciclo?
   805 0000071B 75F4                    	jnz	.division	; si no es 0, el ciclo continua
   806                                  
   807                                  acomoda_digitos:
   808 0000071D BA[84010000]            	mov 	edx,resultado		; edx apunta al buffer<resultado>
   809 00000722 6689D9                  	mov 	cx,bx			; contador se copia
   810                                  
   811                                  .siguente_digito:
   812 00000725 6658                    	pop ax				; saca de la pila 16 bits
   813 00000727 0C30                    	or al,30h			; convierte a ascii
   814 00000729 8802                    	mov [edx],byte al		; escibo en direccion apuntada por edx -> resultado
   815 0000072B 42                      	inc edx				; para escribir bien la siguiente vez
   816 0000072C E2F7                    	loop .siguente_digito		
   817                                  
   818                                  .imprime_numero:
   819 0000072E 6653                    	push 	bx		;guardamos el contador
   820 00000730 B9[84010000]            	mov	ecx,resultado
   821 00000735 31D2                    	xor	edx,edx
   822 00000737 665A                    	pop	dx		;cantidad de digitos
   823 00000739 6642                    	inc	dx	; mostrar "c"
   824 0000073B E819FFFFFF              	call 	DisplayText	
   825                                  	
   826 00000740 89CE                    	mov esi,ecx
   827 00000742 89D7                    	mov edi,edx
   828                                  	
   829 00000744 B9[83010000]            	mov ecx,c	; imprime una "c"
   830 00000749 BA01000000              	mov edx,clen
   831                                  	
   832 0000074E E806FFFFFF              	call 	DisplayText	
   833                                  	
   834 00000753 89F1                    	mov ecx,esi	; imprime el numero de nuevo
   835 00000755 89FA                    	mov edx,edi
   836 00000757 E8FDFEFFFF              	call DisplayText
   837 0000075C 31C9                    	xor ecx,ecx
   838 0000075E 31D2                    	xor edx,edx
   839 00000760 B9[0F000000]            	mov ecx,msgEnter ; imprime un enter
   840 00000765 BA01000000              	mov edx,lenEnter
   841 0000076A E8EAFEFFFF              	call DisplayText
   842                                  	
   843 0000076F C3                      	ret	; retorna, no devuelve nada importante, lo importante es lo que imprimio
